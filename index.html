<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Mobile Photo Grader — Single File</title>
<style>
  :root{
    --bg:#0f1115; --card:#101418; --accent:#1db954; --muted:#9aa3ad;
    --gap:12px; font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;
  }
  html,body{height:100%; margin:0; background:linear-gradient(180deg,#06070a,#0a0c10); color:#e6eef3}
  .wrap{max-width:980px; margin:16px auto; padding:16px;}
  header{display:flex;gap:12px;align-items:center;}
  h1{font-size:18px;margin:0}
  .stage{display:flex;flex-direction:column;gap:12px;margin-top:12px}
  .canvas-wrap{background:linear-gradient(180deg,#0b0d10,#101317);border-radius:12px;padding:8px;display:flex;justify-content:center;align-items:center;min-height:320px}
  canvas{max-width:100%;border-radius:8px;display:block}
  .controls{display:grid;grid-template-columns:1fr;gap:10px;margin-top:10px}
  .row{display:flex;gap:8px;align-items:center}
  label{font-size:12px;color:var(--muted);width:90px}
  input[type=range]{flex:1}
  .presets{display:flex;gap:8px;flex-wrap:wrap}
  .preset-btn{background:#0d1115;border:1px solid #172027;padding:8px 10px;border-radius:8px;color:#dce7ea;font-weight:600;font-size:13px}
  .topbar{display:flex;gap:8px;align-items:center;margin-left:auto}
  .btn{background:var(--accent);color:#04110a;padding:8px 12px;border-radius:8px;font-weight:700;border:none}
  .muted{color:var(--muted);font-size:13px}
  .footer{margin-top:10px;color:var(--muted);font-size:13px;text-align:center}
  .file-input{display:none}
  .small{font-size:12px;color:var(--muted)}
  @media(min-width:720px){ .controls{grid-template-columns:repeat(2,1fr)} label{width:120px} }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Mobile Photo Grader — professional presets</h1>
    <div class="topbar">
      <input id="file" class="file-input" type="file" accept="image/*" />
      <button id="choose" class="preset-btn">Upload Photo</button>
      <button id="download" class="btn" disabled>Download</button>
    </div>
  </header>

  <section class="stage">
    <div class="canvas-wrap">
      <canvas id="canvas" width="1200" height="800"></canvas>
      <div id="placeholder" style="text-align:center;color:#7f8b92;">
        <div style="font-size:14px;margin-bottom:6px">No photo loaded</div>
        <div class="small">Tap "Upload Photo" to pick from your camera roll</div>
      </div>
    </div>

    <div style="display:flex;justify-content:space-between;align-items:center;gap:10px">
      <div class="presets" id="presets">
        <!-- preset buttons injected -->
      </div>
      <div class="muted small">Tip: try "Teal & Orange" then reduce Saturation slightly</div>
    </div>

    <div class="controls" id="controls">
      <!-- slider rows injected -->
    </div>

    <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:6px">
      <button id="reset" class="preset-btn">Reset</button>
      <label style="display:flex;gap:6px;align-items:center"><input id="showGrid" type="checkbox"/> Show grid</label>
      <label style="display:flex;gap:6px;align-items:center"><input id="autoDownload" type="checkbox"/> Auto-download after apply</label>
    </div>

    <div class="footer">Images are processed on-device. No uploads. Built for mobile browsers.</div>
  </section>
</div>

<script>
/*
 Simple mobile-friendly photo grader using canvas 2D filters + overlays.
 Works fully offline in the browser.
*/

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d',{willReadFrequently:false});
const fileInput = document.getElementById('file');
const chooseBtn = document.getElementById('choose');
const downloadBtn = document.getElementById('download');
const placeholder = document.getElementById('placeholder');
const presetsRoot = document.getElementById('presets');
const controlsRoot = document.getElementById('controls');
const resetBtn = document.getElementById('reset');
const autoDownload = document.getElementById('autoDownload');
let img = new Image();
let state = null;

// Presets: each defines the slider defaults.
const PRESETS = {
  "Clean Edit": {brightness:0, contrast:10, saturation:6, hue:0, warmth:0, vignette:12, grain:8},
  "Film Warm (Portra style)": {brightness:4, contrast:6, saturation:8, hue:-2, warmth:18, vignette:8, grain:12},
  "Teal & Orange": {brightness:2, contrast:12, saturation:6, hue:-6, warmth:20, vignette:10, grain:9},
  "Moody": {brightness:-8, contrast:18, saturation:-6, hue:-4, warmth:6, vignette:28, grain:14},
  "High-Contrast B&W": {brightness:-2, contrast:26, saturation:-100, hue:0, warmth:0, vignette:18, grain:18},
  "Bleach Bypass": {brightness:-2, contrast:28, saturation:-18, hue:-4, warmth:0, vignette:6, grain:14}
};

// Sliders meta
const SLIDERS = [
  {key:'brightness', label:'Exposure', min:-40, max:40, step:1},
  {key:'contrast', label:'Contrast', min:-50, max:50, step:1},
  {key:'saturation', label:'Saturation', min:-100, max:100, step:1},
  {key:'hue', label:'Hue', min:-30, max:30, step:1},
  {key:'warmth', label:'Warmth', min:-40, max:40, step:1},
  {key:'vignette', label:'Vignette', min:0, max:60, step:1},
  {key:'grain', label:'Grain', min:0, max:40, step:1}
];

// init UI
function createPresetsUI(){
  for(const name of Object.keys(PRESETS)){
    const btn = document.createElement('button');
    btn.className = 'preset-btn';
    btn.textContent = name;
    btn.addEventListener('click', () => { applyPreset(name); });
    presetsRoot.appendChild(btn);
  }
}

function createControlsUI(){
  for(const s of SLIDERS){
    const row = document.createElement('div'); row.className='row';
    const label = document.createElement('label'); label.textContent = s.label;
    const input = document.createElement('input'); input.type='range';
    input.min = s.min; input.max = s.max; input.step = s.step; input.value = 0;
    input.dataset.key = s.key;
    const val = document.createElement('div'); val.style.minWidth='42px'; val.style.textAlign='right'; val.className='small muted';
    val.textContent = input.value;
    input.addEventListener('input', () => { val.textContent = input.value; updateStateFromControls(); render(); });
    row.appendChild(label); row.appendChild(input); row.appendChild(val);
    controlsRoot.appendChild(row);
  }
}

function readControls(){
  const controls = {};
  controlsRoot.querySelectorAll('input[type=range]').forEach(r => controls[r.dataset.key] = Number(r.value));
  return controls;
}
function setControls(values){
  controlsRoot.querySelectorAll('input[type=range]').forEach(r => {
    if(values[r.dataset.key] !== undefined) r.value = values[r.dataset.key];
    r.dispatchEvent(new Event('input'));
  });
}

function updateStateFromControls(){
  state = Object.assign({}, readControls());
}

// Image load & canvas sizing
function loadImageFromFile(file){
  const url = URL.createObjectURL(file);
  img = new Image();
  img.onload = () => {
    placeholder.style.display='none';
    // fit canvas to device width while keeping ratio (cap width for performance)
    const maxW = Math.min(window.innerWidth*0.98, 1800);
    const scale = Math.min(1, maxW / img.width);
    canvas.width = Math.round(img.width * scale);
    canvas.height = Math.round(img.height * scale);
    // default state
    state = Object.assign({}, PRESETS['Clean Edit']);
    setControls(state);
    render();
    downloadBtn.disabled = false;
    URL.revokeObjectURL(url);
  };
  img.src = url;
}

function applyPreset(name){
  if(!PRESETS[name]) return;
  state = Object.assign({}, PRESETS[name]);
  setControls(state);
  render();
  if(autoDownload.checked) downloadEdited();
}

function resetAll(){
  if(!img.src) return;
  state = Object.assign({}, PRESETS['Clean Edit']);
  setControls(state);
  render();
}

// main render: use ctx.filter for brightness/contrast/saturate/hue/sepia
function render(){
  if(!img || !img.src) return;
  // build filter chain
  // convert slider numbers to CSS filter parameters
  const b = 1 + (state.brightness/50);        // range ~0.2 - 1.8
  const c = 1 + (state.contrast/40);          // range ~0 - 2.25
  const s = 1 + (state.saturation/60);        // range ~- +2
  const hr = (state.hue * 3.5) + 'deg';       // scaled
  // warmth -> map [-40..40] to sepia amount (0..0.6) and a tiny hue-shift
  const sep = Math.max(0, state.warmth/80);
  const warmthHue = (state.warmth * 0.6) + 'deg';

  ctx.clearRect(0,0,canvas.width,canvas.height);
  // draw base with filter
  ctx.save();
  ctx.filter = `brightness(${(b*100).toFixed(0)}%) contrast(${(c*100).toFixed(0)}%) saturate(${(s*100).toFixed(0)}%) hue-rotate(${hr}) sepia(${sep})`;
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  ctx.restore();

  // apply vignette as radial gradient multiply
  if(state.vignette > 0){
    const vig = state.vignette/100;
    ctx.save();
    // create gradient
    const cx = canvas.width/2, cy = canvas.height/2;
    const rad = Math.max(canvas.width, canvas.height) * (0.6 + vig*0.6);
    const g = ctx.createRadialGradient(cx, cy, rad*0.15, cx, cy, rad);
    g.addColorStop(0, 'rgba(0,0,0,0)');
    g.addColorStop(0.6, `rgba(0,0,0,${0.08 * vig})`);
    g.addColorStop(1, `rgba(0,0,0,${0.55 * vig})`);
    ctx.globalCompositeOperation = 'multiply';
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.globalCompositeOperation = 'source-over';
    ctx.restore();
  }

  // add grain overlay
  if(state.grain > 0){
    const grainAmount = state.grain; // 0-40
    // create small noise canvas and scale
    const gW = 256, gH = Math.round(256 * (canvas.height/canvas.width));
    const off = document.createElement('canvas'); off.width = gW; off.height = gH;
    const og = off.getContext('2d');
    const imageData = og.createImageData(gW, gH);
    const data = imageData.data;
    for(let i=0;i<data.length;i+=4){
      const v = 128 + (Math.random()*255-128) * (grainAmount/60);
      data[i]=data[i+1]=data[i+2]=v;
      data[i+3]= (40 * (grainAmount/40)); // alpha
    }
    og.putImageData(imageData,0,0);
    ctx.save();
    ctx.globalAlpha = 0.06 + (grainAmount/220);
    ctx.globalCompositeOperation = 'overlay';
    ctx.drawImage(off, 0, 0, canvas.width, canvas.height);
    ctx.globalCompositeOperation = 'source-over';
    ctx.restore();
  }
}

// Download edited image
function downloadEdited(){
  const link = document.createElement('a');
  link.href = canvas.toDataURL('image/jpeg', 0.92);
  link.download = 'graded.jpg';
  link.click();
}

// events
chooseBtn.addEventListener('click', ()=> fileInput.click());
fileInput.addEventListener('change', e => {
  if(e.target.files && e.target.files[0]) loadImageFromFile(e.target.files[0]);
});
downloadBtn.addEventListener('click', downloadEdited);
resetBtn.addEventListener('click', resetAll);

// wire up keyboard/tap friendly controls
createPresetsUI();
createControlsUI();

// initialize default values visually
state = Object.assign({}, PRESETS['Clean Edit']);
setControls(state);

// optional: allow pinch-zoom on canvas? (Left for future)

// responsiveness: redraw on resize to keep canvas crisp
window.addEventListener('resize', () => {
  if(!img.src) return;
  // re-scale canvas while keeping current settings
  const maxW = Math.min(window.innerWidth*0.98, 1800);
  const scale = Math.min(1, maxW / img.naturalWidth);
  canvas.width = Math.round(img.naturalWidth * scale);
  canvas.height = Math.round(img.naturalHeight * scale);
  render();
});

</script>
</body>
</html>
